#
# Copyright (C) 2022 Ing <https://github.com/wjz304>
# 
# This is free software, licensed under the MIT License.
# See /LICENSE for more information.
#

name: Exts Modules Make

on:
  #schedule:
  #  - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      arpl: 
        description: 'update from arpl'
        default: false
        type: boolean
      poco: 
        description: 'update from poco'
        default: false
        type: boolean
jobs:
  modules:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@main

      - name: Initialization environment
        run : |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          sudo timedatectl set-timezone "Asia/Shanghai"

          sudo apt install build-essential libtool pkgconf libzstd-dev liblzma-dev libssl-dev
          pip install kmodule

      - name: Checkout arpl-modules
        if: inputs.arpl == true
        run: |

          TAG=`curl -skL "https://api.github.com/repos/wjz304/arpl-modules/releases" | jq -r ".[0].tag_name" 2>/dev/null`
          [ -z "${TAG}" ] && echo "get tag error" || echo "TAG: ${TAG}"

          curl -#kL "https://github.com/wjz304/arpl-modules/releases/download/${TAG}/modules.zip" -o "/tmp/modules.zip"
          if [ ! -f "/tmp/modules.zip" ]; then
            echo "get zip error"
            exit 1
          fi
          echo "TAG=${TAG}" >> $GITHUB_ENV

          rm -rf modulesplatforms/*
          unzip /tmp/modules.zip -d modulesplatforms 2>/dev/null

          cd modulesplatforms
          for i in `ls | grep ".*\.tgz"`
          do
            name="`basename "$i" .tgz`"
            [ -d "${name}" ] && rm -rf "${name}"
            mkdir -p "${name}"
            tar -xzf ${i} -C ${name}
          done

      - name: check modulesplatforms
        shell: python
        run: |
          # -*- coding: utf-8 -*-

          import os, json, shutil, hashlib, tarfile, kmodule

          root = '' # os.path.dirname(os.path.abspath(__file__))

          if __name__ == '__main__':
              modulesplatforms = {}
              platformDirs = os.listdir(os.path.join(root, 'modulesplatforms'))
              platformDirs.sort()
              for platformDir in platformDirs:
                  if platformDir.startswith('.') or '-' not in platformDir:
                      continue
                  if os.path.isfile(os.path.join(root, 'modulesplatforms', platformDir)):
                      continue
                  platform = platformDir.split('-')[0]
                  version = platformDir.split('-')[1]
                  modules = os.listdir(os.path.join(root, 'modulesplatforms', platformDir))
                  modules.sort()
                  for module in modules:
                      if module.startswith('.') or '.ko' not in module:
                          continue
                      if os.path.isdir(os.path.join(root, 'modulesplatforms', platformDir, module)):
                          continue
                      #(
                      #    {
                      #        'filename': '/modulesplatforms/apollolake-4.4.180/virtio_input.ko', 
                      #        'author': 'Gerd Hoffmann <kraxel@redhat.com>', 
                      #        'description': 'Virtio input device driver', 
                      #        'license': 'GPL', 
                      #        'depends': 'virtio,virtio_ring', 
                      #        'retpoline': 'Y', 
                      #        'vermagic': '4.4.180+ SMP mod_unload ', 
                      #        'alias': ('virtio:d00000012v*',)
                      #    },
                      #)
                      info = kmodule.modinfo(os.path.join(root, 'modulesplatforms', platformDir, module))[0]
                      info['filename'] = module[:-3]    # module.replace('.ko', '')
                      if 'description' not in info.keys(): info['description'] = ''

                      if platformDir not in modulesplatforms.keys():
                          modulesplatforms[platformDir] = {}
                      modulesplatforms[platformDir][info['filename']] = {}
                      modulesplatforms[platformDir][info['filename']]["description"] = info['description']

              if len(modulesplatforms) > 0:
                  print('###################   modulesplatforms   ###################')
                  print(json.dumps(modules, indent=4))
                  with open(os.path.join(root, 'modulesplatforms.json'), 'w', encoding='utf-8') as f:
                      f.write(json.dumps(modulesplatforms, indent=4))

      #- name: tar modulesplatforms
      #  run: |
      #    for D in `ls -d ${{ github.workspace }}/modulesplatforms/*-*/`; do
      #      [ -f "${D::-1}.tgz" ] && rm -f "${D::-1}.tgz"
      #      tar caf "${D::-1}.tgz" -C "${D}" .
      #    done
      #
      #    D="${{ github.workspace }}/modulesplatforms/firmware/"
      #    [ -f "${D::-1}.tgz" ] && rm -f "${D::-1}.tgz"
      #    tar caf "${D::-1}.tgz" -C "${D}" .

      - name: rm modules
        run: |
          sudo rm -rf modules 

      - name: make modules
        shell: python
        run: |
          # -*- coding: utf-8 -*-

          import os, json, shutil, hashlib, tarfile, kmodule

          root = '' # os.path.dirname(os.path.abspath(__file__))
          baseDir = 'modules'
          baseUrl = '${{ github.server_url }}/${{ github.repository }}/raw/${{ github.ref_name }}'

          if __name__ == '__main__':
              #try:
                  platformDirs = os.listdir(os.path.join(root, 'modulesplatforms'))
                  platformDirs.sort()
                  for platformDir in platformDirs:
                      if platformDir.startswith('.') or '-' not in platformDir:
                          continue
                      if os.path.isfile(os.path.join(root, 'modulesplatforms', platformDir)):
                          continue
                      platform = platformDir.split('-')[0]
                      version = platformDir.split('-')[1]
                      modules = os.listdir(os.path.join(root, 'modulesplatforms', platformDir))
                      modules.sort()
                      for module in modules:
                          if module.startswith('.') or '.ko' not in module:
                              continue
                          if os.path.isdir(os.path.join(root, 'modulesplatforms', platformDir, module)):
                              continue
                          #(
                          #    {
                          #        'filename': '/modulesplatforms/apollolake-4.4.180/virtio_input.ko', 
                          #        'author': 'Gerd Hoffmann <kraxel@redhat.com>', 
                          #        'description': 'Virtio input device driver', 
                          #        'license': 'GPL', 
                          #        'depends': 'virtio,virtio_ring', 
                          #        'retpoline': 'Y', 
                          #        'vermagic': '4.4.180+ SMP mod_unload ', 
                          #        'alias': ('virtio:d00000012v*',)
                          #    },
                          #)
                          info = kmodule.modinfo(os.path.join(root, 'modulesplatforms', platformDir, module))[0]
                          info['filename'] = module[:-3]    # module.replace('.ko', '')
                          if 'description' not in info.keys(): info['description'] = ''

                          checkshell = '#\n# Checking modules is loaded\n#\n\n'
                          universal = { "mod_version": "${{ env.TAG }}", "files": [], "kmods": {}, "scripts": {"on_boot": ""} }

                          kolist = []
                          binlist = []
                          if "depends" in info.keys() and info["depends"] != '': 
                              kolist = [x.strip() + '.ko' for x in info["depends"].split(',') if x.strip() != '']
                          kolist.append(module)

                          os.makedirs(os.path.join(root, baseDir, info['filename'], platformDir), exist_ok=True)

                          for k in kolist:
                              if not os.path.exists(os.path.join(root, 'modulesplatforms', platformDir, k)): continue
                              kinfo = kmodule.modinfo(os.path.join(root, 'modulesplatforms', platformDir, k))[0]
                              if "firmware" in kinfo.keys():
                                  for fw in kinfo["firmware"].split(','):
                                      if not os.path.exists(os.path.join(root, 'modulesplatforms', "firmware", fw)): continue
                                      os.makedirs(os.path.dirname(os.path.join(root, baseDir, info['filename'], platformDir, "firmware", fw)), exist_ok=True)
                                      shutil.copyfile(os.path.join(root, 'modulesplatforms', "firmware", fw), os.path.join(root, baseDir, info['filename'], platformDir, "firmware", fw))
                              shutil.copyfile(os.path.join(root, 'modulesplatforms', platformDir, k), os.path.join(root, baseDir, info['filename'], platformDir, k))
                              checkshell += 'echo -n "Loading module {} -> "\n[ `/sbin/lsmod | grep -i {} | wc -l` -gt 0 ] && echo "Module {} loaded succesfully" || echo "Module {} is not loaded"\n'.format(k[:-3],k[:-3].split('.')[0],k[:-3],k[:-3])
                              url = os.path.join(baseUrl, baseDir, info['filename'], platformDir, k)
                              with open(os.path.join(root, baseDir, info['filename'], platformDir, k), "rb") as f: sha256 = hashlib.sha256(f.read()).hexdigest()
                              universal["files"].append({ "name": k, "url": url, "sha256": sha256, "packed": False })
                              universal["kmods"][k] = ""

                          # checkfile
                          checkfile = "check-{}.sh".format(info['filename'])
                          with open(os.path.join(root, baseDir, info['filename'], platformDir, checkfile), 'w', encoding='utf-8') as f:
                              f.write(checkshell)
                          url = os.path.join(baseUrl, baseDir, info['filename'], platformDir, checkfile)
                          with open(os.path.join(root, baseDir, info['filename'], platformDir, checkfile), "rb") as f: sha256 = hashlib.sha256(f.read()).hexdigest()
                          universal["files"].append({ "name": checkfile, "url": url, "sha256": sha256, "packed": False })
                          universal["scripts"]["on_boot"] = checkfile

                          # firmware
                          if os.path.exists(os.path.join(root, baseDir, info['filename'], platformDir, "firmware")):
                              fwname = "{}_firmware.tag.gz".format(info['filename'])
                              with tarfile.open(os.path.join(root, baseDir, info['filename'], platformDir, fwname), "w:gz") as tar: 
                                  tar.add(os.path.join(root, baseDir, info['filename'], platformDir, "firmware"), arcname=os.path.join(root, baseDir, info['filename'], platformDir, "firmware"))
                              url = os.path.join(baseUrl, baseDir, info['filename'], platformDir, fwname)
                              with open(os.path.join(root, baseDir, info['filename'], platformDir, fwname), "rb") as f: sha256 = hashlib.sha256(f.read()).hexdigest()
                              universal["files"].append({ "name": fwname, "url": url, "sha256": sha256, "packed": False })
                              installfile = "install-{}.sh".format(info['filename'])
                              installshell = '#!/bin/sh\n\ntar -zxvf {} -C /tmpRoot/usr/lib/firmware'.format(fwname)
                              with open(os.path.join(root, baseDir, info['filename'], platformDir, installfile), 'w', encoding='utf-8') as f:
                                  f.write(installshell)
                              url = os.path.join(baseUrl, baseDir, info['filename'], platformDir, installfile)
                              with open(os.path.join(root, baseDir, info['filename'], platformDir, installfile), "rb") as f: sha256 = hashlib.sha256(f.read()).hexdigest()
                              universal["files"].append({ "name": installfile, "url": url, "sha256": sha256, "packed": False })
                              universal["scripts"]["on_os_load"] = installfile
                          with open(os.path.join(root, baseDir, info['filename'], '{}.json'.format(platformDir)), 'w', encoding='utf-8') as f:
                              f.write(json.dumps(universal, indent=4))

                          extsindex = {}
                          if os.path.exists(os.path.join(root, baseDir, info['filename'], 'rpext-index.json')):
                              with open(os.path.join(root, baseDir, info['filename'], 'rpext-index.json'), 'r', encoding='utf-8') as f:
                                  extsindex = json.load(f)
                                  extsindex["releases"][platformDir] = os.path.join(baseUrl, baseDir, info['filename'], '{}.json'.format(platformDir))
                          else:
                              extsindex = {
                                  "id": "ing.{}".format(info['filename']),
                                  "url": os.path.join(baseUrl, baseDir, info['filename'], 'rpext-index.json'), 
                                  "info": {"name": info['filename'], "description": info['description'], "author_url": baseUrl, "packer_url": baseUrl, "help_url": "<todo>"}, 
                                  "releases": { platformDir: os.path.join(baseUrl, baseDir, info['filename'], '{}.json'.format(platformDir)) }
                                  }
                          with open(os.path.join(root, baseDir, info['filename'], 'rpext-index.json'), 'w', encoding='utf-8') as f:
                              f.write(json.dumps(extsindex, indent=4))

              #except Exception as err:
              #    print(err)


      - name: check modules
        shell: python
        run: |
          # -*- coding: utf-8 -*-

          import os, json

          root = '' # os.path.dirname(os.path.abspath(__file__))
          
          def getjsonfile(file):
              data = None
              if os.path.isfile(file):
                  try:
                      with open(file, 'r') as f:
                          data = json.load(f)
                  except Exception as err:
                      print(err)
              return data

          if __name__ == '__main__':

              reglist=[]
              reglist.append(['${{ github.event.repository.url }}/raw/${{ github.event.repository.master_branch }}/',''])
              indexFile = 'rpext-index.json'
              moduleDirs = os.listdir(os.path.join(root, 'modules'))
              moduleDirs.sort()
              modules = {}
              for module in moduleDirs:
                  if module.startswith('.') or os.path.isfile(os.path.join(root, 'modules', module)):
                      continue
                  indexData = getjsonfile(os.path.join(root, 'modules', module, indexFile))
                  if indexData != None:
                      platforms = list(indexData["releases"].keys())
                      modules[module] = { "description": indexData["info"]["description"], "url": indexData["url"], "platforms": platforms }

              if len(modules) > 0:
                  print('#######################   modules   #######################')
                  print(json.dumps(modules, indent=4))
                  with open(os.path.join(root, 'modules.json'), 'w', encoding='utf-8') as f:
                      f.write(json.dumps(modules, indent=4))



      - name: Check and Push
        run: |
          git pull
          status=$(git status -s | grep -E 'modules' | awk '{printf " %s", $2}')
          if [ -n "${status}" ]; then
            git add ${status}
            git commit -m "update $(date +%Y-%m-%d" "%H:%M:%S)"
            git push -f
          fi